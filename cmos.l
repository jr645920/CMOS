%{

#include <string.h>
#include <ctype.h>


/* some internal files generated by bison */
void yyerror(const char *s,...);
void yywarn(const char *s,...);
int yywrap(void) {return(1);}    // should be in library, but here it is for github


const int MAX_QUOTE_STRING_LEN = 256;

/* Everything up to the funny characters on the next line */
/* goes directly into the lex.yy.c file */
%}



/* The rest of this after the '%%' is lex rules */
%%

[ \t]+	        { }  /* Just ignore white space */

[a-zA-Z][\_0-9a-zA-Z]*\=[a-zA-z0-9!@#\$%\^\*()_+=~\[{\];:,./?&]*    {
    //remove quotes
    //replace envariables
    set_env_double_quotes(strdup(yytext)); //only thing needed supposedly
    
}


[a-zA-Z][\_0-9a-zA-Z]*\=\"[^\n\"]*\"    {
    //remove quotes
    //replace envariables
    set_env_double_quotes(strdup(yytext)); //only thing needed supposedly
    
}

[a-zA-Z][\_0-9a-zA-Z]*\=\'[^\n\']*\'' {
    remove_quotes(strdup(yytext));
    return (WORD);
}


\"[^\n\"]*\n    { 
                    yyerror("unterminated string");
                    return(EOLN);
                }

\|[ \t]*\n      {
                    yyerror("syntax error");
                    return(EOLN);
                }

\|[ \t]*\|      {
                    yyerror("syntax error");
                }

"\n" 	        { return(EOLN); } 

\"[^\"\n]*\"    { 
                    char* buf = (char *)malloc(MAX_QUOTE_STRING_LEN);
                    buf = strndup(yytext, MAX_QUOTE_STRING_LEN);

                    /* remove the first char with a saucy mem leak*/
                    buf++;
                    char* cursor = buf;
                    while(*cursor != '\0'){
                        if (*(cursor + 1) == '\0'){
                            *cursor = '\0'; 
                        } 
                        cursor++;
                    }
                    yylval.string = buf;
                    return(WORD);
                }
[-a-zA-z0-9!@#\$%\^\*()_+=~\[{\];:,./?&]+ { 
                    yylval.string = strdup(yytext);
                    return(WORD); 
                }

"|"             { return(PIPE); }

">>"            { return(OUTPUT_APPEND); }

">"             { return(OUTPUT); }

"2>"            { return(ERROR_REDIR); }

"2>>"           { return(ERROR_REDIR_APPEND); }

"<"             { return(INPUT); }

>[>]?[^-a-zA-z0-9!@#\$%\^\*()_+=~\[{\];:,./?][>]+ {
                    yyerror("syntax error");
                }




%{
/* you need rules for the other reserved characters */


/* you need a rule that returns WORD */


/* you need a rule that returns "strings" as WORDS */
%}







.		{
    /* if we haven't matched anything yet, then it's illegal */
    fprintf(stdout, "scanner: Bad character '%c'\n", *yytext);
}


%%
